---
title: "Simple building layout creator"
author: "William Morrison"
date: "19/03/2020"
output: 
  github_document:
    toc: true
    toc_depth: 2
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Summary

Create a simple distribution of buildings. Buildings have square plan area and normally distributed heights. The rotation of buildings can be defined. The output allows saving as data frame (centroids of buildings) and polygon shape file (building plan with height statistics). This document outlines the general R usage.

# Load packages and source the function

```{r, message=FALSE, warning=FALSE}
library(tidyr)
library(rgeos)
library(raster)
library(sp)
library(maptools)
library(rgdal)

source("R/functions.R")
```

# Define parameters
```{r}
#for the random operations
seedVal <- 2361
#total buildings in domain (forces building separation and width)
nBuildings <- 40
#plan area build fraction (lambda_p) (forces building separation and width)
lambda_p <- 0.3
#desired DART domain horizontal length in X and Y (m)
DART_XorY_m <- 430
#DART building size (m) - the size of a DART cube in XYZ.
#all other building sizes in this code are scaled based on this size
DARTbuildSizeXY <- 1
#in XY coordinates, maximum spread of a building centroid from its regular grid location
#(multiplicative factor of distance between building centroids)
#e.g. building centroid distance bD = 10 (m) and XYoffset_factor = 0.5.
#Buildings will randomly be located at x'= x +- 2.5 m and y' = y +- 2.5 m
XYoffset_factor <- 0.25
#maximum building rotation +- north (deg). use 45 deg for most random (assuming nBuildings is large)
maxBuildRotation <- 45
#building heights, to calculate a normal distribution of heights across all buildings
#mean building height (m)
z_mean = 30
#standard deviation of building height (m)
z_sd = 5

```

# Run the function
```{r}
buildDistribution <- createBuildingDistribution(nBuildings = nBuildings, 
                                                lambda_p = lambda_p, 
                                                z_mean = z_mean, 
                                                z_sd = z_sd, 
                                                DART_XorY_m = DART_XorY_m, 
                                                DARTbuildSizeXY = DARTbuildSizeXY,
                                                XYoffset_factor = XYoffset_factor, 
                                                maxBuildRotation = maxBuildRotation, 
                                                seedVal = seedVal)


```


# Explore the output
## Polygons
```{r}
polygonData <- buildDistribution$polygons
#the new domain will be slightly different
newDomainExtent <- bbox(buildDistribution$polygons)

plot(polygonData, main = paste("Seed:", seedVal - 1))
axis(1, at = seq(-DART_XorY_m, DART_XorY_m, by = 20), cex.axis = 0.7)
axis(2, at = seq(-DART_XorY_m, DART_XorY_m, by = 20), cex.axis = 0.7)
rect(xleft = 0, ybottom = 0, xright = newDomainExtent["x", "max"], 
     ytop = newDomainExtent["y", "max"], lwd = 2)
rect(xleft = 0, ybottom = 0, xright = 430, 
     ytop = 430, lwd = 2, lty = 2)
legend("bottomleft", legend = c("Original", "Adjusted"), lty = c(2, 1), lwd = 2, ncol = 1, title = "Domain")

actualPAI <- sum(area(polygonData)) / (newDomainExtent["x", "max"] * newDomainExtent["y", "max"])
print(paste("desired PAI:",lambda_p, "actual PAI:", actualPAI))

polyFile <- "data/samplePoly"

writeOGR(obj = polygonData, dsn = polyFile, driver = "ESRI Shapefile", layer = "z", overwrite_layer = TRUE)


```

## Data frame
```{r}
DARTdfData <- buildDistribution$df
head(DARTdfData)
DFfile <- "data/DART_building_field.txt"
unlink(DFfile)
write.table(x = DARTdfData, file = DFfile, sep = " ", col.names = FALSE, 
            row.names = FALSE, append = TRUE)
```


# Validate across a large range of inputs

```{r}
samplePerms <- expand.grid(nBuildings = seq(20, 140, by = 40), 
                           lambda_p = seq(0.2, 0.8, by = 0.2),
                           DART_XorY_m = seq(400, 1000, by = 400),
                           XYoffset_factor = seq(0, 0.4, by = 0.2),
                           maxBuildRotation = c(0, 45))
library(foreach)
library(doParallel)
nCores <- 6
cl <- parallel::makeCluster(nCores)
doParallel::registerDoParallel(cl)
out <- foreach(i = 1:nrow(samplePerms), .packages = c("raster", "tidyr", "rgeos")) %dopar% {
  createBuildingDistribution(nBuildings = samplePerms$nBuildings[i], 
                             lambda_p = samplePerms$lambda_p[i], 
                             z_mean = z_mean, 
                             z_sd = z_sd, 
                             DART_XorY_m = samplePerms$DART_XorY_m[i], 
                             DARTbuildSizeXY = DARTbuildSizeXY,
                             XYoffset_factor = samplePerms$XYoffset_factor[i], 
                             maxBuildRotation = samplePerms$maxBuildRotation[i], 
                             seedVal = seedVal, maxIters = 50)
  
}
stopCluster(cl)
isFailedSim <- sapply(out, is.null)
out_filtered <- out[which(!isFailedSim)]
calcPAI <- function(x) {
  sum(area(x)) / (bbox(x)["x", "max"] * bbox(x)["y", "max"])
}

finalPAI <- unlist(lapply(out_filtered, function(x) calcPAI(x$polygons)))
expectedPAI <- samplePerms$lambda_p[which(!isFailedSim)]
nIters <- sapply(out_filtered, function(x) x$nIters)
plot(expectedPAI, finalPAI, pch = 20)
abline(0, 1, col = "red")
paste("MAE:", mean(abs(finalPAI - expectedPAI)))


```